
    <!DOCTYPE html>
    <html lang="zh-CN"
            
          
    >
    <head>
    <meta charset="utf-8">
    

    

    
    <title>
        报文传输原理与报文格式 |
        
        大帅哥的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CUbuntu%20Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
    
<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/v4-font-face.min.css">

    
<link rel="stylesheet" href="/css/loader.css">

    <meta name="description" content="HTTP报文传输原理利用TCP&#x2F;IP进行网络通信时，数据包会按照分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。从客户端到服务器的数据，每一帧数据的传输的顺序都为：应用层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;运输层-&gt;应用层。 HTTP报文传输过程以一个HTTP请求的传输为例，请求从HTTP客户端（如浏览器）和">
<meta property="og:type" content="article">
<meta property="og:title" content="报文传输原理与报文格式">
<meta property="og:url" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/index.html">
<meta property="og:site_name" content="大帅哥的博客">
<meta property="og:description" content="HTTP报文传输原理利用TCP&#x2F;IP进行网络通信时，数据包会按照分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。从客户端到服务器的数据，每一帧数据的传输的顺序都为：应用层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;运输层-&gt;应用层。 HTTP报文传输过程以一个HTTP请求的传输为例，请求从HTTP客户端（如浏览器）和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/1.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/2.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/3.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/4.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/5.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/image-20231113094336446.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/7.png">
<meta property="og:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/8.png">
<meta property="article:published_time" content="2023-11-13T01:38:04.000Z">
<meta property="article:modified_time" content="2023-11-13T01:56:22.217Z">
<meta property="article:author" content="雪之下雪乃">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/1.png">
    
        <link rel="alternate" href="/atom.xml" title="大帅哥的博客" type="application/atom+xml">
    
    
        <link rel="shortcut icon" href="/images/favicon.ico">
    
    
        
<link rel="stylesheet" href="https://unpkg.com/typeface-source-code-pro@1.1.13/index.css">

    
    
<link rel="stylesheet" href="/css/style.css">

    
        
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

    
    
    
    
    
<script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script>

    
        
<link rel="stylesheet" href="https://unpkg.com/wowjs@1.1.3/css/libs/animate.css">

        
<script src="https://unpkg.com/wowjs@1.1.3/dist/wow.min.js"></script>

        <script>
          new WOW({
            offset: 0,
            mobile: true,
            live: false
          }).init();
        </script>
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <body>
    
<div id='loader'>
  <div class="loading-left-bg"></div>
  <div class="loading-right-bg"></div>
  <div class="spinner-box">
    <div class="loading-taichi">
      <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
      <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
      <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
      <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
    </svg>
    </div>
    <div class="loading-word">今日解签，宜开卷...</div>
  </div>
</div>
</div>

<script>
  const endLoading = function() {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('load', endLoading);
  document.getElementById('loader').addEventListener('click', endLoading);
</script>


    <div id="container">
        <div id="wrap">
            <header id="header">
    
        <img data-src="/images/1.png" data-sizes="auto" alt="报文传输原理与报文格式" class="lazyload">
    
    <div id="header-outer" class="outer">
        <div id="header-title" class="inner">
            <div id="logo-wrap">
                
                    
                    
                        <a href="/" id="logo"><h1>报文传输原理与报文格式</h1></a>
                    
                
            </div>
            
                
                
            
        </div>
        <div id="header-inner">
            <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/">首页</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/archives">归档</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/about">关于</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/friend">友链</a>
                    </span>
                
            </nav>
            <nav id="sub-nav">
                
                    <a id="nav-rss-link" class="nav-icon" href="/atom.xml"
                       title="RSS 订阅"></a>
                
                
            </nav>
            <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
            </div>
        </div>
    </div>
</header>

            <div id="content" class="outer">
                <section id="main"><article id="post-报文传输原理与报文格式" class="h-entry article article-type-post"
         itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
    <div class="article-inner">
        <div class="article-meta">
            <div class="article-date wow slideInLeft">
    <a href="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/" class="article-date-link">
        <time datetime="2023-11-13T01:38:04.000Z"
              itemprop="datePublished">2023-11-13</time>
    </a>
</div>

            
    <div class="article-category wow slideInLeft">
        <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
    </div>


        </div>
        <div class="hr-line"></div>
        

        <div class="e-content article-entry" itemprop="articleBody">
            
                <h1 id="HTTP报文传输原理"><a href="#HTTP报文传输原理" class="headerlink" title="HTTP报文传输原理"></a>HTTP报文传输原理</h1><p>利用TCP&#x2F;IP进行网络通信时，数据包会按照分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。从客户端到服务器的数据，每一帧数据的传输的顺序都为：应用层-&gt;运输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;运输层-&gt;应用层。</p>
<h1 id="HTTP报文传输过程"><a href="#HTTP报文传输过程" class="headerlink" title="HTTP报文传输过程"></a>HTTP报文传输过程</h1><p>以一个HTTP请求的传输为例，请求从HTTP客户端（如浏览器）和HTTP服务端应用的传输过程，大致如下图所示：</p>
<p><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/1.png"></p>
<h1 id="数据封装和分用"><a href="#数据封装和分用" class="headerlink" title="数据封装和分用"></a>数据封装和分用</h1><p>接下来，为大家介绍一下数据封装和分用。</p>
<p>数据通过互联网传输的时候不可能是光秃秃的不加标识，如果这样数据就会乱。所以数据在发送的时候，需要加上特定标识，加上特定标识的过程叫做数据的封装，在数据使用的时候再去掉特定标识，去掉特定标识的过程就叫做分用。TCP&#x2F;IP协议的数据封装和分用过程，大致如下图所示：<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/2.png"></p>
<p>在数据封装时，数据经过每个层都会打上该层特定标识，添加上头部。</p>
<p>在传输层封装时，添加的报文首部时要存入一个应用程序的标识符，无论TCP和UDP都用一个16位的端口号来表示不同的应用程序，并且都会将源端口和目的端口存入报文首部中。</p>
<p>在网络层封装时，IP首部会标识处理数据的协议类型，或者说标识出网络层数据帧所携带的上层数据类型，如TCP、UDP、ICMP、IP、IGMP等等。<br>具体来说，会在IP首部中存入一个长度为8位的数值，称作协议域：<br>1表示为ICMP协议、2表示为IGMP协议、6表示为TCP协议、17表示为UDP协议、等等。IP首部还会标识发送方地址（源IP）和接收方地址（目标IP）。</p>
<p>在链路层封装时，网络接口分别要发送和接收IP、ARP和RARP等多种不同协议的报文，因此也必须在以太网的帧首部中加入某种形式的标识，以指明所处理的协议类型，为此，以太网的报文帧的首部也有一个16位的类型域，标识出以太网数据帧所携带的上层数据类型，如IPv4、ARP、IPV6、PPPoE等等。</p>
<p>数据封装和分用的过程大致为：发送端每通过一层会增加该层的首部，接收端每通过一层则删除该层的首部。</p>
<p>总体来说，TCP&#x2F;IP分层管理、数据封装和分用的好处：分层之后若需改变相关设计，只需替换变动的层。各层之间的接口部分规划好之后，每个层次内部的设计就可以自由改动。层次化之后，设计也变得相对简单：各个层只需考虑分派给自己的传输任务。</p>
<p>TCP&#x2F;IP与OSI的区别主要有哪些呢？除了TCP&#x2F;IP与OSI在分层模块上稍有区别，更重要的区别为：OSI参考模型注重“通信协议必要的功能是什么”，而TCP&#x2F;IP则更强调“在计算机上实现协议应该开发哪种程序”。</p>
<p>实际上，在传输过程中，数据报文会在不同的物理网络之间传递，还是以一个HTTP请求的传输为例，请求在不同物理网络之间的传输过程，大致如下图所示：<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/3.png"></p>
<p>图：HTTP请求在不同物理网络之间的传输过程</p>
<p>数据包在不同物理网络之间的传输过程中，网络层会通过路由器去对不同的网络之间的数据包进行存储、分组转发处理。构造互连网最简单的方法是把两个或多个网络通过路由器进行连接。路由器可以简单理解为一种特殊的用于网络互连的硬件盒，其作用是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。</p>
<p>物理网络之间通过路由器进行互连，随着增加不同类型的物理网络，可能会有很多个路由器，但是对于应用层来说仍然是一样的，TCP协议栈为大家屏蔽了物理层的复杂性。总之，物理细节和差异性的隐藏，使得互联网TCP&#x2F;IP传输的功能变得非常强大。</p>
<p>接下来，开始为大家介绍与传输性能有密切关系的内容：TCP传输层的三次握手建立连接，四次挥手释放连接。不过在此之前，还得先介绍一下TCP报文协议。</p>
<h1 id="TCP协议的报文格式"><a href="#TCP协议的报文格式" class="headerlink" title="TCP协议的报文格式"></a>TCP协议的报文格式</h1><p>在TCP&#x2F;IP协议栈中，IP协议层只关心如何使数据能够跨越本地网络边界的问题，而不关心数据如何传输。整体TCP&#x2F;IP协议栈，共同配合一起解决数据如何通过许许多多个点对点通路，顺利传输到达目的地。一个点对点通路被称为一“跳”（hop），通过TCP&#x2F;IP协议栈，网络成员能够在许多“跳”的基础上建立相互的数据通路。</p>
<p>传输层TCP协议提供了一种面向连接的、可靠的字节流服务，其数据帧格式，大致如下图所示：<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/4.png"></p>
<p>一个传输层TCP协议的数据帧，大致包含以下字段：</p>
<h2 id="（一）源端口号"><a href="#（一）源端口号" class="headerlink" title="（一）源端口号"></a>（一）源端口号</h2><p>源端口号表示报文的发送端口，占16位。源端口和源IP地址组合起来，可以标识报文的发送地址。</p>
<h2 id="（二）目的端口号"><a href="#（二）目的端口号" class="headerlink" title="（二）目的端口号"></a>（二）目的端口号</h2><p>目的端口号表示报文的接收端口，占16位。目的端口和目的IP地址相结合，可以标识报文的接收地址。</p>
<p>TCP协议是基于IP协议的基础上传输的，TCP报文中的源端口号+源IP，与TCP报文中的目的端口号+目的IP一起，组合起来唯一性的确定一条TCP连接。</p>
<h2 id="（三）序号（Sequence-Number）"><a href="#（三）序号（Sequence-Number）" class="headerlink" title="（三）序号（Sequence Number）"></a>（三）序号（Sequence Number）</h2><p>TCP传输过程中，在发送端出的字节流中，传输报文中的数据部分的每一个字节都有它的编号。序号（Sequence<br>Number）占32位，发起方发送数据时，都需要标记序号。</p>
<p>序号（Sequence Number）的语义与SYN控制标志（Control<br>Bits）的值有关。根据控制标志（Control Bits）中的SYN是否为1，序号（Sequence<br>Number）表达不同的含义：</p>
<p>（1）当SYN &#x3D; 1时，当前为连接建立阶段，此时的序号为初始序号ISN((Initial Sequence<br>Number)，通过算法来随机生成序号；</p>
<p>（2）当SYN &#x3D; 0时在数据传输正式开始时，第一个报文的序号为 ISN +<br>1，后面的报文的序号，为前一个报文的SN值+TCP报文的净荷字节数(不包含TCP头)。比如，如果发送端发送的一个TCP帧的净荷为12byte，序号为5，则发送端接着发送的下一个数据包的时候，序号的值应该设置为5+12&#x3D;17。</p>
<p>在数据传输过程中，TCP协议通过序号（Sequence<br>Number）对上层提供有序的数据流。发送端可以用序号来跟踪发送的数据量；接收端可以用序号识别出重复接收到的TCP包，从而丢弃重复包；对于乱序的数据包，接收端也可以依靠序号对其进行排序。</p>
<h2 id="（四）确认序号（Acknowledgment-Number）"><a href="#（四）确认序号（Acknowledgment-Number）" class="headerlink" title="（四）确认序号（Acknowledgment Number）"></a>（四）确认序号（Acknowledgment Number）</h2><p>确认序号（Acknowledgment<br>Number）标识了报文接收端期望接收的字节序列。如果设置了ACK控制位，确认序号的值表示一个准备接收的包的序列码，注意，它所指向的是准备接收的包，也就是下一个期望接收的包的序列码。</p>
<p>举个例子，假设发送端（如Client）发送3个净荷为1000byte、起始SN序号为1的数据包给Server服务端，Server每收到一个包之后，需要回复一个ACK响应确认数据包给Client。ACK响应数据包的ACK<br>Number值，为每个Client包的为SN+包净荷，既表示Server已经确认收到的字节数，还表示期望接收到的下一个Client发送包的SN序号，具体的ACK值如下图左边的正常传输部分所示。<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/5.png"></p>
<p>在上图的左边部分，Server第1个ACK包的ACK<br>Number值为1001，是通过Client第1个包的SN+包净荷&#x3D;1+1000计算得到，表示期望第2个Client包的SN序号为1001；Server第2个ACK包的ACK<br>Number值为2001，为Client第2个包的SN+包净荷&#x3D;2001，表示期望第3个Server包的SN为2001，以此类推。</p>
<p>如果发生错误，假设Server在处理Client的第二个发送包异常，Server仍然回复一个ACK<br>Number值为1001的确认包，则Client的第二个数据包需要重复发送，具体的ACK值如上图右边的正常传输部分所示。</p>
<p>只有控制标志的ACK标志为1时，数据帧中的确认序号ACK<br>Number才有效。TCP协议规定，连接建立后，所有发送的报文的ACK必须为1，也就是建立连接后，所有报文的确认序号有效。如果是SYN类型的报文，其ACK标志为0，故没有确认序号。</p>
<h2 id="（五）头部长度"><a href="#（五）头部长度" class="headerlink" title="（五）头部长度"></a>（五）头部长度</h2><p>该字段占用4位，用来表示TCP报文首部的长度，单位是4bit位。其值所表示的并不是字节数，而是头部的所含有的32bit的数目（或者倍数），或者4个字节的倍数，所以TCP头部最多可以有60字节（4*15&#x3D;60）。没有任何选项字段的TCP头部长度为20字节，所以其头部长度为5，可以通过20&#x2F;4&#x3D;5计算得到。</p>
<h2 id="（六）预留6位"><a href="#（六）预留6位" class="headerlink" title="（六）预留6位"></a>（六）预留6位</h2><p>头部长度后面预留的字段长度为6位，作为保留字段，暂时没有什么用处。</p>
<h2 id="（七）控制标志"><a href="#（七）控制标志" class="headerlink" title="（七）控制标志"></a>（七）控制标志</h2><p>控制标志（Control<br>Bits）共6个bit位，具体的标志位为：URG、ACK、PSH、RST、SYN、FIN。6个标志位的说明，如下表所示。</p>
<p>表：TCP报文控制标志（Control Bits）说明<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/image-20231113094336446.png"></p>
<p>在连接建立的三次握手过程中，若只是单个SYN置位，表示的只是建立连接请求。如果SYN和ACK同时置位为1，表示的建立连接之后的响应。</p>
<h2 id="（八）窗口大小："><a href="#（八）窗口大小：" class="headerlink" title="（八）窗口大小："></a>（八）窗口大小：</h2><p>长度为16位，共2个字节。此字段用来进行流量控制。流量控制的单位为字节数，这个值是本端期望一次接收的字节数。</p>
<h2 id="（九）校验和："><a href="#（九）校验和：" class="headerlink" title="（九）校验和："></a>（九）校验和：</h2><p>长度为16位，共2个字节。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，接收端用于对收到的数据包进行验证。</p>
<h2 id="（十）紧急指针："><a href="#（十）紧急指针：" class="headerlink" title="（十）紧急指针："></a>（十）紧急指针：</h2><p>长度为16米，2个字节。它是一个偏移量，和SN序号值相加表示紧急数据最后一个字节的序号。</p>
<p>以上十项内容是TCP报文首部必须的字段，也称固有字段，长度为20个字节。接下来是TCP报文的可选项和填充部分。</p>
<h2 id="（十一）可选项和填充部分"><a href="#（十一）可选项和填充部分" class="headerlink" title="（十一）可选项和填充部分"></a>（十一）可选项和填充部分</h2><p>可选项和填充部分的长度为4n字节（n是整数），该部分是根据需要而增加的选项。如果不足4n字节，要加填充位，使得选项长度为32位（4字节）的整数倍，具体的做法是在这个字段中加入额外的零，以确保TCP头是32位（4字节）的整数倍。</p>
<p>最常见的选项字段是MSS（Maximum Segment<br>Size最长报文大小），每个连接方通常都在通信的第一个报文段（SYN标志为1的那个段）中指明这个选项字段，表示当前连接方所能接受的最大报文段的长度。</p>
<p>由于可选项和填充部分不是必须的，所以TCP报文首部最小长度为20个字节。</p>
<p>至此，TCP报文首部的字段，就全部介绍完了。TCP报文首部的后面，接着的是数据部分，不过数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据，比如在处理超时的过程中，也会发送不带任何数据的报文段。</p>
<h1 id="总体来说，TCP协议的可靠性，主要通过以下几点来保障："><a href="#总体来说，TCP协议的可靠性，主要通过以下几点来保障：" class="headerlink" title="总体来说，TCP协议的可靠性，主要通过以下几点来保障："></a>总体来说，TCP协议的可靠性，主要通过以下几点来保障：</h1><p>（1）应用数据分割成TCP认为最适合发送的数据块。这部分是通过MSS（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS规定了TCP传往另一端的最大数据块的长度。值得注意的是，MSS只能出现在SYN报文段中，若一方不接收来自另一方的MSS值，则MSS就定为536字节。一般来讲，MSS值还是越大越好，这样可以提高网络的利用率。</p>
<p>（2）重传机制。设置定时器，等待确认包，如果定时器超时还没有收到确认包，则报文重传。</p>
<p>（3）对首部和数据进行校验。</p>
<p>（4）接收端对收到的数据进行排序，然后交给应用层。</p>
<p>（5）接收端丢弃重复的数据。</p>
<p>（6）TCP还提供流量控制，主要是通过滑动窗口来实现流量控制。</p>
<p>至此TCP协议的数据帧格式介绍完了。接下来开始为大家重点介绍：TCP传输层的三次握手建立连接，四次挥手释放连接。</p>
<h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p>TCP连接的建立时，双方需要经过三次握手，而断开连接时，双方需要经过四次分手，那么，其三次握手和四次分手分别做了什么呢？又是如何进行的呢？</p>
<p>通常情况下，建立连接的双方，由一端打开一个监听套接字（ServerSocket）来监听来自请求方的TCP（Socket）连接，当服务器端监听开始时，必须做好准备接受外来的连接，在Java中该操作通过创建一个ServerSocket服务监听套接字实例来完成，此操作会调用底层操作系统（如Linux）的C代码中三个函数socket()、bind()、listen()<br>来完成。开始监听之后，服务器端就做好接受外来连接的准备，如果监听到建立新连接的请求，会开启一个传输套接字，称之为被动打开（Passive<br>Open）。</p>
<p>一段简单的服务端监听新连接请求，并且被动打开（Passive<br>Open）传输套接字的Java示例代码，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SocketServer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">// 创建服务端socket</span><br><span class="line"></span><br><span class="line">ServerSocket serverSocket = new ServerSocket(8080);</span><br><span class="line"></span><br><span class="line">//循环监听等待客户端的连接</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">//监听到客户端连接，传输套接字被动开启</span><br><span class="line"></span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">//开启线程进行连接的IO处理</span><br><span class="line"></span><br><span class="line">ServerThread thread = new ServerThread(socket);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">// 处理异常</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<p>客户端在发起连接建立时，Java代码通过创建Socket实例，调用底层的connect(…)方法，主动打开(Active<br>Open)Socket连接。套接字监听方在收到请求之后，监听方和发起方（客户端）之间就会建立一条的连接通道，该通道由双方IP和双方端口所唯一确定。</p>
<p>一段简单的客户端连接主动打开(Active Open)的Java示例代码，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SocketClient &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">// 和服务器创建连接</span><br><span class="line"></span><br><span class="line">Socket socket = new Socket(&quot;localhost&quot;,8080);</span><br><span class="line"></span><br><span class="line">// 写入给监听方的输出流</span><br><span class="line"></span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">…..</span><br><span class="line"></span><br><span class="line">// 读取监听方的输入流</span><br><span class="line"></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">…..</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h1><p>TCP连接的建立时，双方需要经过三次握手，具体过程如下：</p>
<h2 id="（1）第一次握手："><a href="#（1）第一次握手：" class="headerlink" title="（1）第一次握手："></a>（1）第一次握手：</h2><p>Client进入SYN_SENT状态，发送一个SYN帧来主动打开传输通道，该帧的SYN标志位被设置为1，同时会带上Client分配好的SN序列号，该SN是根据时间产生的一个随机值，通常情况下每间隔4ms会加1。除此之外，SYN帧还会带一个MSS（最大报文段长度）可选项的值，表示客户端发送出去的最大数据块的长度。</p>
<h2 id="（2）第二次握手："><a href="#（2）第二次握手：" class="headerlink" title="（2）第二次握手："></a>（2）第二次握手：</h2><p>Server端在收到SYN帧之后，会进入SYN_RCVD状态，同时返回SYN+ACK帧给Client，主要目的在于通知Client，Server端已经收到SYN消息，现在需要进行确认。Server端发出的SYN+ACK帧的ACK标志位被设置为1，其确认序号AN（Acknowledgment<br>Number）值被设置为Client的SN+1；SYN+ACK帧的SYN标志位被设置为1，SN值为Server端生成的SN序号；SYN+ACK帧的MSS（最大报文段长度）表示的是Server端的最大数据块长度。</p>
<h2 id="（3）第三次握手："><a href="#（3）第三次握手：" class="headerlink" title="（3）第三次握手："></a>（3）第三次握手：</h2><p>Client在收到Server的第二次握手SYN+ACK确认帧之后，首先将自己的状态会从SYN_SENT变成ESTABLISHED，表示自己方向的连接通道已经建立成功，Client可以发送数据给Server端了。然后，Client发ACK帧给Server端，该ACK帧的ACK标志位被设置为1，其确认序号AN（Acknowledgment<br>Number）值被设置为Server端的SN序列号+1。还有一种情况，Client可能会将ACK帧和第一帧要发送的数据，合并到一起发送给Server端。</p>
<p>（4）Server端在收到Client的ACK帧之后，会从SYN_RCVD状态会进入ESTABLISHED状态，至此，Server方向的通道连接建立成功，Server可以发送数据给Client，TCP的全双工连接建立完成。</p>
<p>三次握手的图解<br>三次握手的交互过程，具体如下图所示：<br>![]6.png)</p>
<p>图：TCP建立的连接时三次握手示意图</p>
<p>Client和Server完成了三次握手后，双方就进入了数据传输的阶段。数据传输完成后，连接将断开，连接断开的过程需要经历四次挥手。</p>
<h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p>业务数据通信完成之后，TCP连接开始断开（或者拆接）的过程，在这个过程中连接的每个端的都能独立地、主动的发起，断开的过程TCP协议使用了四路挥手操作。</p>
<p>四次挥手具体过程<br>四次挥手具体过程，具体如下：</p>
<h2 id="（1）第一次挥手："><a href="#（1）第一次挥手：" class="headerlink" title="（1）第一次挥手："></a>（1）第一次挥手：</h2><p>主动断开方（可以是客户端，也可以是服务器端），向对方发送一个FIN结束请求报文，此报文的FIN位被设置为1，并且正确设置Sequence<br>Number（序列号）和Acknowledgment<br>Number（确认号）。发送完成后，主动断开方进入FIN_WAIT_1状态，这表示主动断开方没有业务数据要发送给对方，准备关闭SOCKET连接了。</p>
<h2 id="（2）第二次挥手："><a href="#（2）第二次挥手：" class="headerlink" title="（2）第二次挥手："></a>（2）第二次挥手：</h2><p>正常情况下，在收到了主动断开方发送的FIN断开请求报文后，被动断开方会发送一个ACK响应报文，报文的Acknowledgment<br>Number（确认号）值为断开请求报文的Sequence Number<br>（序列号）加1，该ACK确认报文的含义是：“我同意你的连接断开请求”。之后，被动断开方就进入了CLOSE-WAIT（关闭等待）状态，TCP协议服务会通知高层的应用进程，对方向本地方向的连接已经关闭，对方已经没有数据要发送了，若本地还要发送数据给对方，对方依然会接受。被动断开方的CLOSE-WAIT（关闭等待）还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>主动断开方在收到了ACK报文后，由FIN_WAIT_1转换成FIN_WAIT_2状态。</p>
<h2 id="（3）第三次挥手："><a href="#（3）第三次挥手：" class="headerlink" title="（3）第三次挥手："></a>（3）第三次挥手：</h2><p>在发送完成ACK报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成后，或者CLOSE-WAIT（关闭等待）截止后，被动断开方会向主动断开方发送一个FIN+ACK结束响应报文，表示被动断开方的数据都发送完了，然后，被动断开方进入LAST_ACK状态。</p>
<h2 id="（4）第四次挥手："><a href="#（4）第四次挥手：" class="headerlink" title="（4）第四次挥手："></a>（4）第四次挥手：</h2><p>​	主动断开方收在到FIN+ACK断开响应报文后，还需要进行最后的确认，向被动断开方发送一个ACK确认报文，然后，自己就进入TIME_WAIT状态，等待超时后最终关闭连接。处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，如果期间没有收到其他报文，则证明对方已正常关闭，主动断开方的连接最终关闭。</p>
<p>被动断开方在收到主动断开方的最后的ACK报文以后，最终关闭了连接，自己啥也不管了。</p>
<p>四次挥手图解<br>四次挥手的全部交互过程，具体如下图所示：<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/7.png"></p>
<p>图：TCP建立的连接时四次挥手的示意图</p>
<h3 id="处于TIME-WAIT状态的主动断开方，在等待完成2MSL的时间后，才真正关闭连接通道，其等待的时间为什么是2MSL呢？"><a href="#处于TIME-WAIT状态的主动断开方，在等待完成2MSL的时间后，才真正关闭连接通道，其等待的时间为什么是2MSL呢？" class="headerlink" title="处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，才真正关闭连接通道，其等待的时间为什么是2MSL呢？"></a>处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，才真正关闭连接通道，其等待的时间为什么是2MSL呢？</h3><p>​	2MSL翻译过来就是两倍的MSL。MSL全称为Maximum Segment<br>​	Lifetime，指的是一个TCP报文片段在网络中最大的存活时间，具体来说，2MSL对应于一次消息的来回（一个发送和一个回复）所需的最大时间。如果直到2MSL，主动断开方都没有再一次收到对方的报文（如FIN报文），则可以推断ACK已经被对方成功接收，此时，主动断开方将最终结束自己的TCP连接。所以，TCP的TIME_WAIT状态也称为2MSL等待状态。</p>
<p>​	有关MSL的具体的时间长度，在RFC1122协议中推荐为2分钟。在SICS（瑞典计算机科学院）开发的一个小型开源的TCP&#x2F;IP协议栈——LwIP开源协议栈中MSL默认为1分钟。在源自Berkeley的TCP协议栈实现中MSL默认长度为30秒。总体来说，TIME_WAIT（2MSL）等待状态的时间长度，一般维持在1-4分钟之间。</p>
<p>通过三次握手建立连接和四次挥手拆除连接，一次TCP的连接建立及拆除，至少进行7次通信，可见其成本是很高的。</p>
<h1 id="三次握手、四次挥手的常见面试题"><a href="#三次握手、四次挥手的常见面试题" class="headerlink" title="三次握手、四次挥手的常见面试题"></a>三次握手、四次挥手的常见面试题</h1><p>有关TCP的连接建立的三次握手及拆除过程的四次挥手的面试问题，是技术面试过程中的出现频率很高的重点和难点问题，常见问题大致如下：</p>
<h2 id="问题（1）：为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"><a href="#问题（1）：为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="问题（1）：为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>问题（1）：为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h2><p>​	关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>​	而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>
<h2 id="问题（2）：为什么连接建立的时候是三次握手，可以改成两次握手吗？"><a href="#问题（2）：为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="问题（2）：为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>问题（2）：为什么连接建立的时候是三次握手，可以改成两次握手吗？</h2><p>​	三次握手完成两个重要的功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。</p>
<p>​	如果把三次握手改成两次握手，可能发生死锁。两次握手的话，缺失了Client的二次确认ACK帧，假想的TCP建立的连接时二次挥手，可以如下图所示：<br><img src="/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/8.png"></p>
<p>图：假想的TCP建立的连接时二次握手的示意图</p>
<p>​	在假想的TCP建立的连接时二次握手过程中，Client发送Server发送一个SYN请求帧，Server收到后发送了确认应答SYN+ACK帧。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据帧。这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。</p>
<h2 id="问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"><a href="#问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h2><h2 id="原因之一："><a href="#原因之一：" class="headerlink" title="原因之一："></a>原因之一：</h2><p>​	主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。</p>
<p>假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。</p>
<p>​	在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。</p>
<p>​	反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<h2 id="原因之二："><a href="#原因之二：" class="headerlink" title="原因之二："></a>原因之二：</h2><p>​	防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，</p>
<p>​	这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>
<h2 id="问题（4）：如果已经建立了连接，但是Client端突然出现故障了怎么办？"><a href="#问题（4）：如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="问题（4）：如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>问题（4）：如果已经建立了连接，但是Client端突然出现故障了怎么办？</h2><p>​	TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。</p>
<p>​	每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。</p>
<p>​	若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。</p>

            
        </div>
        <footer class="article-footer">
            <a data-url="http://example.com/2023/11/13/%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/" data-id="clow97ba5000958zc1saxa3bp" data-title="报文传输原理与报文格式"
               class="article-share-link">分享</a>
            
            
            
            
    <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>


        </footer>
    </div>
    
        
    <nav id="article-nav" class="wow fadeInUp">
        
        
            <div class="article-nav-link-wrap article-nav-link-right">
                
                    
                    
                        <img data-src="/covers/girl_warrior_profile_1093371_1280x720.jpg" data-sizes="auto" alt="详细阐述通信原理" class="lazyload">
                    
                
                <a href="/2023/11/12/%E8%AF%A6%E7%BB%86%E9%98%90%E8%BF%B0%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"></a>
                <div class="article-nav-caption">后一篇</div>
                <h3 class="article-nav-title">
                    
                        详细阐述通信原理
                    
                </h3>
            </div>
        
    </nav>


    
</article>











</section>
                
                    <aside id="sidebar">
    <div class="sidebar-wrap wow fadeInRight">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="雪之下雪乃" class="lazyload">
            <div class="sidebar-author-name">雪之下雪乃</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>文章</div>
                <div class="sidebar-state-number">5</div>
            </div>
            <div class="sidebar-state-category">
                <div>分类</div>
                <div class="sidebar-state-number">2</div>
            </div>
            <div class="sidebar-state-tag">
                <div>标签</div>
                <div class="sidebar-state-number">2</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">首页</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">归档</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">关于</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">友链</div>
                </div>
            
        </div>
    </div>
    
        
    <div class="widget-wrap wow fadeInRight">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0/">搜索学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li></ul>
        </div>
    </div>


    
        
    <div class="widget-wrap wow fadeInRight">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">网络</a>
        </div>
    </div>


    
        
    <div class="widget-wrap wow fadeInRight">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li></ul>
        </div>
    </div>


    
</aside>

                
            </div>
            <footer id="footer" class="wow fadeInUp">
    <div style="width: 100%; overflow: hidden"><div class="footer-line"></div></div>
    <div class="outer">
        <div id="footer-info" class="inner">
            
            <div>
                <span class="icon-copyright"></span>
                2023.11.11-2023
                <span class="footer-info-sep"></span>
                雪之下雪乃
            </div>
            
                <div>
                    基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
                    Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
                </div>
            
            
                <div>
                    <span class="icon-brush"></span>
                    13.6k
                    &nbsp;|&nbsp;
                    <span class="icon-coffee"></span>
                    00:48
                </div>
            
            
                <div>
                    <span class="icon-eye"></span>
                    <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
                    &nbsp;|&nbsp;
                    <span class="icon-user"></span>
                    <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
                </div>
            
        </div>
    </div>
</footer>

        </div>
        <nav id="mobile-nav">
    <div class="sidebar-wrap">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="雪之下雪乃" class="lazyload">
            <div class="sidebar-author-name">雪之下雪乃</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>文章</div>
                <div class="sidebar-state-number">5</div>
            </div>
            <div class="sidebar-state-category">
                <div>分类</div>
                <div class="sidebar-state-number">2</div>
            </div>
            <div class="sidebar-state-tag">
                <div>标签</div>
                <div class="sidebar-state-number">2</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com/yourname itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">首页</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">归档</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">关于</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">友链</div>
                </div>
            
        </div>
    </div>
</nav>

        
<script src="https://unpkg.com/jquery@3.7.0/dist/jquery.min.js"></script>


<script src="https://unpkg.com/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://unpkg.com/clipboard@2.0.11/dist/clipboard.min.js"></script>



    
<script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>



    
<script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script>






<script src="/js/script.js"></script>
















    </div>
    <div class="site-search">
        <div class="algolia-popup popup">
            <div class="algolia-search">
                <span class="algolia-search-input-icon"></span>
                <div class="algolia-search-input" id="algolia-search-input"></div>
            </div>

            <div class="algolia-results">
                <div id="algolia-stats"></div>
                <div id="algolia-hits"></div>
                <div id="algolia-pagination" class="algolia-pagination"></div>
            </div>

            <span class="popup-btn-close"></span>
        </div>
    </div>
    <!-- hexo injector body_end start -->
<script src="/js/insertHighlight.js"></script>
<!-- hexo injector body_end end --></body>
    </html>

